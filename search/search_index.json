{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p><code>pogo-migrate</code> assists with maintaining your database schema (and data if required) as it evolves.  Pogo supports migrations written in raw sql, as well as python files (useful when data needs to be migrated).</p> <p>A migration can be as simple as:</p> <pre><code>-- a descriptive message\n-- depends: 20210101_01_abcdef-previous-migration\n\n-- migrate: apply\nCREATE TABLE foo (id INT, bar VARCHAR(20), PRIMARY KEY (id));\n\n-- migrate: rollback\nDROP TABLE foo;\n</code></pre> <p>Pogo manages these migration scripts and provides command line tools to apply, rollback and show migration history.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>You can configure pogo using <code>pogo init</code> or you can add pogo to pyproject.toml manually.</p> <pre><code>[tool.pogo]\nmigrations_location = \"./migrations\"\ndatabase_config = \"{POSTGRES_DSN}\"\nschema = \"public\"\n</code></pre> <p>If you have an existing environment with separate configuration values for postgres, you can build the DSN in config.</p> <pre><code>[tool.pogo]\nmigrations_location = \"./migrations\"\ndatabase_config = \"postgres://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_HOST}:{POSTGRES_PORT}/{PORTGRES_DATABASE}\"\nschema = \"public\"\n</code></pre> <p>If you are using the cli purely to generate new migrations files and running them directly via <code>migrate.apply</code> the <code>database_config</code> configuration can be left out.</p> <p>If any commands are run that require a database connection, and the <code>--database</code> option is not provided, it will raise an invalid configuration error.</p>"},{"location":"configuration/#squash-migration-exclusions","title":"Squash migration exclusions","text":"<p>Some migrations can not be squashed due to complexity, or you might just want to keep them stand alone. Additional configuration can be added to exclude specific migrations from being included when <code>pogo squash</code> is run.</p> <pre><code>[tool.pogo.squash]\nexclude = [\"migration-id-1\", \"migration-id-5\"]\n</code></pre>"},{"location":"configuration/#schema-configuration","title":"Schema configuration","text":"<p>If you want migrations to run in a specific (or default) schema, you can define it in configuration, this value can be overridden per call in the CLI if you need to run the migrations against multiple schemas.</p>"},{"location":"testing/","title":"Testing","text":"<p>To assist in testing, <code>pogo-migrate</code> provides the <code>pogo_migrate.testing</code> module. The apply/rollback methods in the testing module will pick up your configuration and connect to the configured test database based on environment variables, or you can provide a database connection directly.</p> <pre><code>import asyncpg\nimport pogo_migrate.testing\n\n@pytest.fixture(scope=\"session\")\nasync def _engine(config):  # noqa: PT005\n    db = await asyncpg.connect(config.my_postgres_dsn)\n\n    await pogo_migrate.testing.apply(db)\n\n    yield\n\n    await pogo_migrate.testing.rollback(db)\n</code></pre> <p>Alternatively add pytest-pogo to your test dependencies and use the provided fixture <code>pogo_engine</code> which will apply and rollback your migrations for your test session, like the above example.</p>"},{"location":"testing/#core","title":"Core","text":"<p>If you are not making use of the user interface and just want a code based solution, <code>pogo-core</code> package can be used instead.</p> <pre><code>from pathlib import Path\n\nimport asyncpg\nimport pogo_core.util.testing\n\nmigrations_path = Path(\"path/to/migrations\")\n\n\n@pytest.fixture(scope=\"session\")\nasync def _engine(config):  # noqa: PT005\n    db = await asyncpg.connect(config.my_postgres_dsn)\n\n    await pogo_migrate.testing.apply(migrations_path, db)\n\n    yield\n\n    await pogo_migrate.testing.rollback(migrations_path, db)\n</code></pre>"},{"location":"thanks/","title":"Thanks and Credit","text":"<p>Inspiration for this tool is drawn from yoyo and dbmate.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#setting-up","title":"Setting up","text":"<p>To help with getting started, the <code>pogo init</code> command will initialise the migrations folder, as well as setup the basic configuration for <code>pogo</code>.</p> <p>Supported flags:</p> <ul> <li><code>-m, --migrations-location</code> defines the name of the migrations folder   (defaults to <code>./migrations</code>)</li> <li><code>-d, --database-env-key</code> defines the environment variable (or template to   build from environment variables) for the database dsn. See   configuration for   examples. For setups running migrations purely in code, this configuration   can be omitted.</li> <li><code>--schema</code> defines the default schema migrations will be run against.</li> </ul>"},{"location":"usage/#migrating-from-yoyo","title":"Migrating from yoyo","text":"<p>If you are coming here having previously used <code>yoyo</code>, a lot of migrations can be directly converted to <code>pogo</code> (namely sql migrations). Python migrations will be copied across as is, and will require manual updating to use async functions.</p> <p>Supported flags:</p> <ul> <li><code>-d, --database</code> postgres dsn to load yoyo history, and store pogo history   tables.</li> <li><code>--skip-files, --no-skip-files</code> skip migration files and just copy the yoyo   history in the database. (defaults to <code>--no-skip-files</code>)</li> <li><code>--dotenv, --no-dotenv</code> load environment from local <code>.env</code> file. (defaults to   <code>--no-dotenv</code>)</li> </ul> <p>Locally you will want to migrate files and data, but in a deployed environment your code will likely already contain the migrated files, and as such just the database history needs to be copied. In deployed environments <code>--skip-files</code> would be used.</p>"},{"location":"usage/#new-migrations","title":"New migrations","text":"<p>To create a new migration use <code>pogo new</code>. This will template out the migration file and open the file in your configured text editor (<code>vi</code> by default).</p> <p>Supported flags:</p> <ul> <li><code>--py</code> generate a python migration (defaults to <code>.sql</code>)</li> <li><code>--no-interactive</code> skip the editor step and just write the migration template   to the migrations directory.</li> </ul> <pre><code>$ pogo new -m \"a descriptive message\"\n</code></pre>"},{"location":"usage/#applying-migrations","title":"Applying migrations","text":"<p>To apply (unapplied) migrations, run <code>pogo apply</code>. Any previously run migrations will be skipped over, and any new ones will be run in (topological, based on dependency graph) order.</p> <p>Supported flags:</p> <ul> <li><code>-d, --database</code> optional database dsn to connect to, if not provided will   fall back to configuration.</li> <li><code>--dotenv, --no-dotenv</code> load environment from local <code>.env</code> file. (defaults to   <code>--no-dotenv</code>)</li> <li><code>--schema</code> override default schema for migrations being applied.</li> <li><code>--create-schema</code> optional flag to create the schema before running initial migrations.</li> </ul>"},{"location":"usage/#marking-a-migration-as-applied","title":"Marking a migration as applied","text":"<p>In some scenarios a migration will be added to track changes to the database that might have been made on the fly as part of a fix. To maintain history and keep later databases in sync. In this scenario, the migration does not need to be applied, as such <code>pogo mark</code> will step through unapplied migrations and confirm which ones to mark as applied.</p> <ul> <li><code>-d, --database</code> optional database dsn to connect to, if not provided will   fall back to configuration.</li> <li><code>--dotenv, --no-dotenv</code> load environment from local <code>.env</code> file. (defaults to   <code>--no-dotenv</code>)</li> <li><code>--interactive, --no-interactive</code> confirm all changes. (defaults to `--interactive)</li> <li><code>--schema</code> override default schema for migration to be marked.</li> </ul>"},{"location":"usage/#rolling-back-migrations","title":"Rolling back migrations","text":"<p>To rollback (applied) migrations, run <code>pogo rollback</code>. By default the most recently applied migration will be rolled back.</p> <p>Supported flags:</p> <ul> <li><code>-c, --count</code> number of migrations to rollback. (defaults to <code>1</code>)</li> <li><code>-d, --database</code> optional database dsn to connect to, if not provided will   fall back to configuration.</li> <li><code>--dotenv, --no-dotenv</code> load environment from local <code>.env</code> file. (defaults to   <code>--no-dotenv</code>)</li> <li><code>--schema</code> override default schema for migrations being rolled back.</li> <li><code>--drop-schema</code> optional flag to drop migration schema if all migrations   rolled back.</li> </ul>"},{"location":"usage/#marking-a-migration-as-rolled-back","title":"Marking a migration as rolled back","text":"<p>To flag a migration as rolled back (without actually rolling back), <code>pogo unmark</code> will mark a migration as unapplied.</p> <ul> <li><code>-d, --database</code> optional database dsn to connect to, if not provided will   fall back to configuration.</li> <li><code>--dotenv, --no-dotenv</code> load environment from local <code>.env</code> file. (defaults to   <code>--no-dotenv</code>)</li> <li><code>--schema</code> override default schema for migrations being rolled back.</li> </ul>"},{"location":"usage/#multiple-schemas","title":"Multiple schemas","text":"<p>If you have multiple projects with their own migrations that you wish to manage in a single database with separate migrations per project. Configure each project with the desired schema, and apply migrations as normal. The configuration will ensure they are run in the correct schema.</p> <p>If you have a single project with migrations that you wish to manage in multiple schemas, use the <code>--schema</code> override flag.</p> <p>For example:</p> <pre><code>$ pogo apply --schema companya\n$ pogo apply --schema companyb\n$ pogo rollback --count -1 --schema companyb\n</code></pre>"},{"location":"usage/#view-migration-status","title":"View migration status","text":"<p><code>pogo history</code> will list available migrations. Each migration will be prefixed with one of U (unapplied) or A (applied), as well as the migration format <code>sql</code> or <code>py</code>.</p> <ul> <li><code>--unapplied, --no-applied</code> show only unapplied migrations. (defaults to <code>--no-unapplied</code>)</li> <li><code>--simple, --no-simple</code> show history as raw data, instead of a pretty printed table. (defaults to <code>--no-simple</code>)</li> <li><code>-d, --database</code> optional database dsn to connect to, if not provided will   fall back to configuration.</li> <li><code>--dotenv, --no-dotenv</code> load environment from local <code>.env</code> file. (defaults to   <code>--no-dotenv</code>)</li> <li><code>--schema</code> override default schema.</li> </ul> <p><code>pogo history</code> can be useful in docker containers to prevent start up of an application until migrations are completed, i.e. checking that there are no unapplied migrations.</p> <pre><code>$ pogo history --unapplied --simple | wc -l\n</code></pre>"},{"location":"usage/#managing-migrations","title":"Managing migrations","text":"<p>These commands are mostly experimental and should be used with caution.  They have been tested on multiple projects but it is likely not all edge cases have been found yet.  Please raise any issues you find when using them in github.</p>"},{"location":"usage/#remove-a-migration-from-the-dependency-chain","title":"Remove a migration from the dependency chain","text":"<p>Remove a specific migration from the dependency chain. This can be useful to remove hotfixes or data migrations that are only needed in live environments, but not in newly deployed environments.</p> <p>For example a migration to clean up legacy data is not needed in a fresh environment and can be removed once all live databases have been updated.</p> <p>Supported flags:</p> <ul> <li><code>-m, --migrations-location</code> defines the name of the migrations folder   (defaults to configured location)</li> <li><code>--backup</code> keep any removed files with <code>.bak</code> suffix.</li> </ul>"},{"location":"usage/#squashing-migrations","title":"Squashing migrations","text":"<p><code>pogo squash</code> will perform a best effort to iterate through all migrations, and detect where multiple migrations can be condensed into a single migration.</p> <p>Python migrations and non transaction based transactions are skipped by default.</p> <p>Statements in sql migrations are grouped by table, and applied in the order tables where discovered.</p> <p>Rollback statements follow the reverse logic, the last table discovered is grouped first.</p> <p>Supported flags:</p> <ul> <li><code>-m, --migrations-location</code> defines the name of the migrations folder   (defaults to configured location)</li> <li><code>--backup</code> keep any removed files with <code>.bak</code> suffix.</li> <li><code>--source</code> add a comment to each extracted statement with the source   migration id.</li> <li><code>--update-prompt</code> prompt before inclusion of an update statement, the   previous and following statements are included in the prompt. This is helpful   for removing <code>NULL, update, NOT NULL</code> flows that are not required in a   squashed migration.</li> <li><code>--skip-prompt</code> prompt before skipping files that can not be squashed (python   migrations, non transaction migrations). Allows for removal of unnecessary   migrations.</li> </ul>"},{"location":"usage/#cleaning-up-backups","title":"Cleaning up backups","text":"<p><code>pogo clean</code> will remove <code>.bak</code> files created during <code>remove</code> and <code>squash</code> commands.</p> <p>Supported flags:</p> <ul> <li><code>-m, --migrations-location</code> defines the name of the migrations folder   (defaults to configured location)</li> </ul>"},{"location":"usage/#validate-migration-sql","title":"Validate migration sql","text":"<p><code>pogo validate</code> will iterate through all migrations and do a best effort attempt to validate each sql statement to report any potential issues, like using reserved keywords as table names without quoting etc.</p> <p>Supported flags:</p> <ul> <li><code>-m, --migrations-location</code> defines the name of the migrations folder   (defaults to configured location)</li> </ul>"},{"location":"usage/#usage-in-python","title":"Usage in python","text":"<p>If you want to manage your migrations in python code rather than through the cli. The migrate module provides the interface required.</p> <pre><code>from pogo_migrate import config, migrate, sql\n\nc = config.load_config()\nconn = await sql.get_connection(c.database_dsn)\n\nawait migrate.apply(db=conn, migrations_dir=c.migrations)\nawait migrate.rollback(db=conn, migrations_dir=c.migrations)\n</code></pre> <p>An optional <code>logger</code> parameter can be provided to override the internal logger in both <code>apply()</code> and <code>rollback()</code>.</p> <p>Alternatively if you already have access to the migrations location and a database connection (for example from an application framework), the code can be simplified down to.</p> <pre><code>from pogo_migrate import config, migrate\n\nc = config.load_config()\nconn = await asyncpg.connect(c.postgres_dsn)\n\nawait migrate.apply(db=conn, migrations_dir=c.migrations)\nawait migrate.rollback(db=conn, migrations_dir=c.migrations)\n</code></pre>"},{"location":"usage/#core","title":"Core","text":"<p>In the case you want to manage migrations outside of development and don't want to install all the interface dependencies, <code>pogo-core</code> package provides the underlying supporting code.</p> <pre><code>from pathlib import Path\n\nfrom pogo_core.util import migrate, sql\n\nmigrations_dir = Path(\"path/to/migrations\")\nconn = await sql.get_connection(database_dsn)\n\nawait migrate.apply(db=conn, migrations_dir=migrations_dir)\nawait migrate.rollback(db=conn, migrations_dir=migrations_dir)\n</code></pre> <p>An optional <code>logger</code> parameter can be provided to override the internal logger in both <code>apply()</code> and <code>rollback()</code>.</p>"},{"location":"why-pogo/","title":"Why does pogo exist?","text":"<p><code>pogo-migrate</code> was born out of a lack of support for async migration (and testing) support in the yoyo library. As well as a lack of recent development in <code>yoyo</code>.</p> <p>This library is intended for use with asyncpg exclusively.</p>"}]}